/*
 * sshkeytransfer.cpp
 *
 *  Created on: 2017年10月9日
 *      Author: hongxu
 *
 * Generate a pair of RSA public/private key using system's openssl command.
 * Create a pair of source files in the current directory: public_key.cpp and
 * private_key.cpp. The original key bytes are further XORed with a list of
 * predefined bytes (in CCrypt.h) before inserting into the global variable:
 * g_public_key and g_private_key, in public_key.cpp and private_key.cpp
 * respectively.
 *
 * Both the tunnel agent server and client use this pair of keys
 * for communication. sshkeytransfer is used to generate the key pair at build
 * time and thus the keys are hardcoded into the executables. The encryption and
 * decrypttion jobs should be handled by CCrypt.
 *
 */

#include <ctype.h>
#include <errno.h>
#include <fcntl.h>
#include <stdint.h>
#include <stdio.h>
#include <string.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>

#include <iostream>
#include <string>

#include "CCrypt.h"
using namespace std;

static string g_xorstr((char *)g_xorkey, sizeof(g_xorkey));

void transfer(string &key) {
  uint32_t len = key.size();
  uint32_t xorlen = g_xorstr.size();

  uint8_t *p = (uint8_t *)key.data();
  for (uint32_t i = 0, j = 0; i < len; i++) {
    *p++ ^= (uint8_t)g_xorstr[j++];
    if (j == xorlen) j = 0;
  }
}

bool saveKeyToSourceFile(string valname, string val, string file_name) {
  string cpp = file_name + ".cpp";
  string header = file_name + ".h";
  FILE *fp = fopen(cpp.c_str(), "w+t");
  if (!fp) {
    fprintf(stderr, "open file %s err.\n", cpp.c_str());
    return false;
  }

  fprintf(fp,
          "/*\n*\tthis file is generated by sshkeytransfer program.\n*\tDO NOT "
          "EDIT IT.\n*/\n\n");
  fprintf(fp, "#include <string>\n#include <stdint.h>\n#include \"%s\"\n\n",
          header.c_str());
  fprintf(fp, "static const uint8_t %s_tmp[] = {\n\t", valname.c_str());

  for (int i = 0; i < val.size() - 1; i++) {
    fprintf(fp, "0x%02x,", (unsigned char)val[i]);
    if ((i + 1) % 40 == 0) fprintf(fp, "\n\t");
  }
  fprintf(fp, "0x%02x", (unsigned char)val[val.size() - 1]);
  fprintf(fp, "\n};\n\n");
  fprintf(fp, "const std::string %s((char*)%s_tmp, sizeof(%s_tmp));\n\n",
          valname.c_str(), valname.c_str(), valname.c_str());

  fclose(fp);
  return true;
}

bool readFile(string file, string &content) {
  int fd = open(file.c_str(), O_CLOEXEC | O_RDONLY);
  if (fd < 0) {
    fprintf(stderr, "cannot open file %s err: %s\n", file.c_str(),
            strerror(errno));
    return false;
  }

  int ret = 0;
  char buf[1024];
  while ((ret = read(fd, buf, sizeof(buf))) > 0) {
    content.append(buf, ret);
  }

  while (content.size()) {
    if (isspace(content[content.size() - 1]))
      content.resize(content.size() - 1);
    else
      break;
  }

  if (content.empty()) {
    fprintf(stderr, "read file %s err: %s\n", file.c_str(), strerror(errno));
    return false;
  }
  return true;
}

void genRsaKey() {
  unlink("./rsa_private_key.pem");
  unlink("./rsa_public_key.pem");

  system("openssl genrsa -out rsa_private_key.pem 1024");
  system("openssl rsa -in rsa_private_key.pem -pubout -out rsa_public_key.pem");
}

bool genPublicSourceFile() {
  string content;
  if (!readFile("./rsa_public_key.pem", content)) return false;

  transfer(content);

  unlink("./public_key.cpp");
  return saveKeyToSourceFile("g_public_key", content, "public_key");
}

bool genPrivateSourceFile() {
  string content;
  if (!readFile("./rsa_private_key.pem", content)) return false;

  transfer(content);

  unlink("./private_key.cpp");
  return saveKeyToSourceFile("g_private_key", content, "private_key");
}

int main() {
  genRsaKey();

  if (genPublicSourceFile() && genPrivateSourceFile()) {
    printf("generate rsa key source file succ.\n");
    return 0;
  }

  printf("generate rsa key source file failed!\n");
  return -1;
}
